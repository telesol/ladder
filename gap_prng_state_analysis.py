#!/usr/bin/env python3
"""
PRNG STATE ANALYSIS

CRITICAL HYPOTHESIS: What if the creator used a PRNG but stored the STATE
at specific checkpoints (e.g., every 5 puzzles)?

This would explain:
1. Why k[75] can be generated without k[71-74]
2. Why the formula appears complex
3. Why there are no simple polynomial/trigonometric patterns

If states are stored at n=5,10,15,20,...,70,75,80,85,90, the creator could:
- Generate k[1-5] from initial seed
- Store state after k[5]
- Jump to that state to generate k[6-10]
- Store state after k[10]
- etc.

This allows generating ANY multiple of 5 independently!
"""

import sqlite3
from decimal import Decimal, getcontext

getcontext().prec = 150

DB_PATH = "/home/solo/LA/db/kh.db"

def get_keys(puzzle_ids):
    """Load keys from database"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    keys = {}
    for pid in puzzle_ids:
        cursor.execute("SELECT priv_hex FROM keys WHERE puzzle_id=?", (pid,))
        result = cursor.fetchone()
        if result:
            keys[pid] = int(result[0], 16)
    conn.close()
    return keys

def simulate_lcg(seed, a, c, m, count):
    """
    Linear Congruential Generator
    X[n+1] = (a * X[n] + c) mod m
    """
    state = seed
    values = []

    for _ in range(count):
        state = (a * state + c) % m
        values.append(state)

    return values, state

def test_lcg_checkpoint_hypothesis(keys):
    """
    Test if keys could be generated by LCG with checkpoints
    """
    print("="*80)
    print("LCG CHECKPOINT HYPOTHESIS")
    print("="*80)
    print("\nHypothesis: Keys generated by LCG, with state saved at multiples of 5")
    print("This allows jumping to any checkpoint without computing intermediate values\n")

    # Get checkpoint keys (multiples of 5)
    checkpoints = sorted([n for n in keys.keys() if n % 5 == 0])

    print(f"Checkpoints available: {checkpoints}\n")

    # For LCG to work, we need to find a, c, m such that:
    # offset[n+1] = (a * offset[n] + c) mod m

    # Try common LCG parameters
    test_params = [
        # (a, c, m, name)
        (1103515245, 12345, 2**31, "glibc"),
        (214013, 2531011, 2**32, "MSVC"),
        (1664525, 1013904223, 2**32, "Numerical Recipes"),
        (69069, 1, 2**32, "Super-Duper"),
        (22695477, 1, 2**32, "Borland C++"),
    ]

    # Get offsets
    offsets = {}
    for n in keys.keys():
        offsets[n] = keys[n] - 2**(n-1)

    print("Testing known LCG parameters:\n")

    for a, c, m, name in test_params:
        print(f"{name}: a={a}, c={c}, m={m}")

        # Test if consecutive checkpoints follow this LCG
        matches = 0
        total = 0

        for i in range(len(checkpoints) - 1):
            n1 = checkpoints[i]
            n2 = checkpoints[i + 1]

            if n1 in offsets and n2 in offsets:
                offset1 = offsets[n1]
                offset2 = offsets[n2]

                # For multi-step LCG (n2 = n1 + 5), we need to advance 5 times
                # But offsets grow with 2^n, so normalize

                # Predict offset2 from offset1
                # This is simplified - real test would be more complex
                predicted = (a * offset1 + c) % m

                if offset2 % m == predicted:
                    matches += 1

                total += 1

        print(f"  Matches: {matches}/{total}\n")

def analyze_state_transition_matrix(keys):
    """
    If this is a linear recurrence, we might find a state transition matrix
    """
    print("="*80)
    print("STATE TRANSITION MATRIX ANALYSIS")
    print("="*80)
    print("\nIf k[n] = A*k[n-1] + B*k[n-2] + ... (linear recurrence)")
    print("We can find coefficients by solving system of equations\n")

    sorted_n = sorted(keys.keys())

    # Try 2-term recurrence: k[n] = a*k[n-1] + b
    print("Testing k[n] = a*k[n-1] + b:\n")

    for i in range(1, min(10, len(sorted_n) - 1)):
        n0 = sorted_n[i-1]
        n1 = sorted_n[i]
        n2 = sorted_n[i+1]

        if n1 == n0 + 1 and n2 == n1 + 1:  # Consecutive
            k0 = keys[n0]
            k1 = keys[n1]
            k2 = keys[n2]

            # From k[n0] and k[n1], solve for a and b
            # k[n1] = a*k[n0] + b
            # k[n2] = a*k[n1] + b

            # Eliminate b: k[n2] - k[n1] = a*(k[n1] - k[n0])
            if k1 != k0:
                a = Decimal(k2 - k1) / Decimal(k1 - k0)
                b = Decimal(k1) - a * Decimal(k0)

                print(f"From k[{n0}], k[{n1}], k[{n2}]:")
                print(f"  a = {a}")
                print(f"  b = {b}")

                # Verify with next value
                if i + 2 < len(sorted_n):
                    n3 = sorted_n[i+2]
                    if n3 == n2 + 1:
                        k3 = keys[n3]
                        k3_predicted = a * Decimal(k2) + b
                        error = abs(k3_predicted - Decimal(k3))

                        print(f"  Verification: k[{n3}] predicted = {k3_predicted}")
                        print(f"                k[{n3}] actual    = {k3}")
                        print(f"                error = {error}")

                        if error < 1:
                            print("  ✓ MATCH!\n")
                        else:
                            print("  ✗ No match\n")

def analyze_bit_shift_patterns(keys):
    """
    Many PRNGs use bit shifts. Check if consecutive keys have bit shift relationships
    """
    print("="*80)
    print("BIT SHIFT PATTERN ANALYSIS")
    print("="*80)
    print("\nMany PRNGs use XOR with bit shifts (Xorshift, Mersenne Twister, etc.)")
    print("Testing if k[n] XOR k[n-1] shows patterns\n")

    sorted_n = sorted(keys.keys())

    for i in range(1, min(11, len(sorted_n))):
        n_prev = sorted_n[i-1]
        n_curr = sorted_n[i]

        if n_curr == n_prev + 1:  # Consecutive
            k_prev = keys[n_prev]
            k_curr = keys[n_curr]

            xor_val = k_prev ^ k_curr

            print(f"k[{n_prev}] XOR k[{n_curr}] = {xor_val}")
            print(f"  Binary: {bin(xor_val)}")
            print(f"  Popcount: {bin(xor_val).count('1')}/{max(n_prev, n_curr)} bits")

            # Check if it's a simple shift
            if k_curr == (k_prev << 1):
                print("  ✓ k[n] = k[n-1] << 1\n")
            elif k_curr == (k_prev >> 1):
                print("  ✓ k[n] = k[n-1] >> 1\n")
            else:
                print()

def analyze_fibonacci_lfsr(keys):
    """
    Test if this could be a Fibonacci Linear Feedback Shift Register
    """
    print("="*80)
    print("FIBONACCI LFSR ANALYSIS")
    print("="*80)
    print("\nLFSR generates sequence where each term is XOR of previous terms")
    print("Testing if k[n] = k[n-1] XOR k[n-k] for some k\n")

    sorted_n = sorted(keys.keys())

    # Test various tap positions
    for tap in [2, 3, 5, 7, 11, 13]:
        print(f"Testing tap = {tap}:")

        matches = 0
        tests = 0

        for i in range(tap, min(tap + 10, len(sorted_n))):
            if i < len(sorted_n):
                n_curr = sorted_n[i]
                n_prev = sorted_n[i-1]
                n_tap = sorted_n[i-tap]

                # Only test if consecutive
                if n_curr == n_prev + 1 and n_tap + tap == n_curr:
                    k_curr = keys[n_curr]
                    k_prev = keys[n_prev]
                    k_tap = keys[n_tap]

                    predicted = k_prev ^ k_tap
                    tests += 1

                    if predicted == k_curr:
                        matches += 1
                        print(f"  ✓ n={n_curr}: k[{n_curr}] = k[{n_prev}] XOR k[{n_tap}]")

        if tests > 0:
            print(f"  Matches: {matches}/{tests}\n")
        else:
            print(f"  No consecutive sequences to test\n")

def main():
    print("="*80)
    print("PRNG STATE/CHECKPOINT HYPOTHESIS ANALYSIS")
    print("="*80)

    # Load all keys
    all_puzzle_ids = list(range(1, 71)) + [75, 80, 85, 90]
    keys = get_keys(all_puzzle_ids)

    print(f"\nLoaded {len(keys)} keys\n")

    # Run analyses
    test_lcg_checkpoint_hypothesis(keys)
    analyze_state_transition_matrix(keys)
    analyze_bit_shift_patterns(keys)
    analyze_fibonacci_lfsr(keys)

    print("\n" + "="*80)
    print("CONCLUSION")
    print("="*80)
    print("""
If no PRNG pattern found, the most likely explanations are:

1. CRYPTOGRAPHIC PRNG (impossible to reverse without seed)
   - Uses hash functions (SHA256, etc.)
   - Each k[n] generated independently
   - Cannot be predicted

2. MANUAL SELECTION
   - Creator chose keys deliberately
   - May have embedded patterns (π, e, φ convergents)
   - Patterns exist but are intentionally obscure

3. COMPLEX ALGORITHMIC GENERATION
   - Multi-stage process
   - Combines multiple techniques
   - Designed to resist analysis

The GAP puzzles (70, 75, 80, 85, 90) are key:
- If generated by simple PRNG: we should find the pattern
- If generated by crypto PRNG: impossible to predict
- If manually selected: look for mathematical clues

Next step: Focus on mathematical patterns in actual key values,
especially relationships to known constants (π, e, φ).
""")

if __name__ == "__main__":
    main()
