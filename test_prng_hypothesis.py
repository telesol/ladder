#!/usr/bin/env python3
"""
Test Priority 1: PRNG/Seed-based Generation Hypothesis

This tests whether k[n] values could be generated by common PRNGs:
1. Linear Congruential Generator (LCG)
2. LFSR (Linear Feedback Shift Register)
3. adj[n] follows deterministic recurrence

Key insight: If k[n] comes from PRNG, we should be able to:
- Find seed that reproduces the sequence
- Detect statistical patterns matching PRNG output
"""

import sqlite3
from pathlib import Path
from math import gcd
from collections import Counter

DB_PATH = Path(__file__).parent / "db" / "kh.db"

def load_k_values():
    """Load known k values from database."""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("""
        SELECT puzzle_id, priv_hex
        FROM ground_truth
        WHERE priv_hex IS NOT NULL
        ORDER BY puzzle_id
    """)
    rows = c.fetchall()
    conn.close()

    k = {}
    for puzzle_id, priv_hex in rows:
        k[puzzle_id] = int(priv_hex, 16)
    return k

def compute_adj(k):
    """Compute adj[n] = k[n] - 2*k[n-1]."""
    adj = {}
    for n in sorted(k.keys()):
        if n >= 2 and (n-1) in k:
            adj[n] = k[n] - 2*k[n-1]
    return adj

def compute_m_d(k):
    """Compute m[n] and d[n] for each n."""
    m_vals = {}
    d_vals = {}

    for n in sorted(k.keys()):
        if n < 2 or (n-1) not in k:
            continue

        adj_n = k[n] - 2 * k[n-1]
        numerator = (1 << n) - adj_n

        best_d = 1
        best_m = numerator

        for d in range(1, n):
            if d in k and k[d] != 0 and numerator % k[d] == 0:
                m = numerator // k[d]
                if abs(m) < abs(best_m):
                    best_m = m
                    best_d = d

        m_vals[n] = best_m
        d_vals[n] = best_d

    return m_vals, d_vals

def test_lcg_detection(sequence):
    """
    Test if sequence follows LCG: x_{n+1} = (a*x_n + c) mod m

    Method: Check if (x3-x2)/(x2-x1) is constant
    """
    print("\n" + "="*60)
    print("Test 1: Linear Congruential Generator (LCG) Detection")
    print("="*60)

    ratios = []
    for i in range(2, min(20, len(sequence))):
        if sequence[i] != sequence[i-1] and sequence[i-1] != sequence[i-2]:
            diff1 = sequence[i] - sequence[i-1]
            diff2 = sequence[i-1] - sequence[i-2]
            if diff2 != 0:
                ratio = diff1 / diff2
                ratios.append(ratio)
                print(f"  n={i+1}: diff_ratio = {ratio:.6f}")

    if ratios:
        # Check if ratios are constant (LCG signature)
        mean_ratio = sum(ratios) / len(ratios)
        variance = sum((r - mean_ratio)**2 for r in ratios) / len(ratios)
        print(f"\nMean ratio: {mean_ratio:.6f}")
        print(f"Variance: {variance:.6f}")

        if variance < 0.01:
            print("RESULT: Possible LCG pattern (low variance)")
            return True
        else:
            print("RESULT: NOT an LCG pattern (high variance)")

    return False

def test_lfsr_detection(k):
    """
    Test if k[n] mod 2 follows LFSR pattern.
    LFSR produces periodic binary sequences.
    """
    print("\n" + "="*60)
    print("Test 2: Linear Feedback Shift Register (LFSR) Detection")
    print("="*60)

    # Get binary LSBs of k[n]
    bits = []
    for n in sorted(k.keys())[:70]:
        bits.append(k[n] & 1)

    print(f"LSB sequence (first 30): {bits[:30]}")

    # Check for periodicity
    for period in range(2, 20):
        match = True
        for i in range(period, min(period*3, len(bits))):
            if bits[i] != bits[i % period]:
                match = False
                break
        if match:
            print(f"FOUND: Periodic pattern with period {period}")
            return True

    # Check for LFSR recurrence: bit[n] = XOR of previous bits
    print("\nTesting LFSR recurrence (XOR of previous bits):")
    for taps in [(1,2), (1,3), (1,4), (2,3), (2,4), (1,2,3), (1,2,4)]:
        matches = 0
        for i in range(max(taps), len(bits)):
            predicted = 0
            for t in taps:
                predicted ^= bits[i-t]
            if predicted == bits[i]:
                matches += 1
        match_pct = 100 * matches / (len(bits) - max(taps))
        if match_pct > 60:
            print(f"  Taps {taps}: {match_pct:.1f}% match")

    # Count 0s and 1s
    zeros = bits.count(0)
    ones = bits.count(1)
    print(f"\nLSB distribution: {zeros} zeros, {ones} ones ({100*ones/len(bits):.1f}% ones)")

    return False

def test_adj_recurrence(adj):
    """
    Test if adj[n] follows a deterministic recurrence.
    """
    print("\n" + "="*60)
    print("Test 3: adj[n] Recurrence Pattern Detection")
    print("="*60)

    adj_list = [adj[n] for n in sorted(adj.keys())]

    # Test linear recurrence: adj[n] = a*adj[n-1] + b*adj[n-2] + c
    print("\nTesting linear recurrence adj[n] = a*adj[n-1] + b*adj[n-2] + c:")

    # Solve system for a, b, c using first few values
    if len(adj_list) >= 5:
        # Use numpy-like approach manually
        # adj[3] = a*adj[2] + b*adj[1] + c
        # adj[4] = a*adj[3] + b*adj[2] + c
        # adj[5] = a*adj[4] + b*adj[3] + c

        # Check various simple ratios
        print("  Checking ratio patterns:")
        for i in range(2, min(15, len(adj_list))):
            if adj_list[i-1] != 0:
                ratio = adj_list[i] / adj_list[i-1]
                print(f"    adj[{i+2}]/adj[{i+1}] = {ratio:.4f}")

    # Check sign pattern
    signs = ['+' if a > 0 else '-' if a < 0 else '0' for a in adj_list]
    sign_str = ''.join(signs[:30])
    print(f"\nSign pattern (first 30): {sign_str}")

    # Find repeated sign subsequences
    for pattern_len in [3, 4, 5, 6]:
        pattern = sign_str[:pattern_len]
        matches = 0
        for i in range(0, len(sign_str) - pattern_len, pattern_len):
            if sign_str[i:i+pattern_len] == pattern:
                matches += 1
        if matches > 2:
            print(f"  Pattern '{pattern}' repeats {matches} times")

    return False

def test_binary_patterns(k):
    """
    Test binary representation patterns in k[n].
    """
    print("\n" + "="*60)
    print("Test 4: Binary Representation Patterns")
    print("="*60)

    hamming_weights = []
    bit_lengths = []

    for n in sorted(k.keys())[:30]:
        val = k[n]
        hw = bin(val).count('1')
        bl = val.bit_length()
        hamming_weights.append(hw)
        bit_lengths.append(bl)
        print(f"  k[{n}] = {val:>15} = 0b{bin(val)[2:]:>20s}  HW={hw:>2}, bits={bl}")

    print(f"\nHamming weight stats:")
    print(f"  Mean: {sum(hamming_weights)/len(hamming_weights):.2f}")
    print(f"  Min: {min(hamming_weights)}, Max: {max(hamming_weights)}")

    # Expected HW for random n-bit number is n/2
    expected_hw = sum(bl/2 for bl in bit_lengths) / len(bit_lengths)
    actual_mean_hw = sum(hamming_weights) / len(hamming_weights)
    print(f"  Expected (random): {expected_hw:.2f}")
    print(f"  Actual: {actual_mean_hw:.2f}")

    if actual_mean_hw < expected_hw * 0.8:
        print("  INTERESTING: Lower than expected Hamming weights!")
    elif actual_mean_hw > expected_hw * 1.2:
        print("  INTERESTING: Higher than expected Hamming weights!")

def test_gcd_patterns(k):
    """
    Test GCD relationships between consecutive k values.
    """
    print("\n" + "="*60)
    print("Test 5: GCD Patterns")
    print("="*60)

    k_sorted = sorted(k.keys())

    print("GCD(k[n], k[n-1]):")
    for i in range(1, min(20, len(k_sorted))):
        n = k_sorted[i]
        prev = k_sorted[i-1]
        if n - prev == 1:  # Consecutive
            g = gcd(k[n], k[prev])
            print(f"  GCD(k[{n}], k[{prev}]) = {g}")

    print("\nGCD(k[n], k[n-2]):")
    for i in range(2, min(20, len(k_sorted))):
        n = k_sorted[i]
        prev2 = k_sorted[i-2]
        if n - prev2 == 2:
            g = gcd(k[n], k[prev2])
            print(f"  GCD(k[{n}], k[{prev2}]) = {g}")

    # Check which k values are coprime with all previous
    print("\nCoprimality check (k[n] coprime with ALL previous k[m]):")
    for i, n in enumerate(k_sorted[:20]):
        coprime_with_all = True
        for j in range(i):
            m = k_sorted[j]
            if gcd(k[n], k[m]) > 1:
                coprime_with_all = False
                break
        if coprime_with_all and i > 0:
            print(f"  k[{n}] = {k[n]} is COPRIME with all previous k values!")

def test_modular_patterns(k):
    """
    Test if k[n] mod small primes follows patterns.
    """
    print("\n" + "="*60)
    print("Test 6: Modular Arithmetic Patterns")
    print("="*60)

    primes = [3, 7, 17, 31, 127]  # Mersenne-related primes

    for p in primes:
        residues = []
        for n in sorted(k.keys())[:30]:
            residues.append(k[n] % p)

        print(f"k[n] mod {p}: {residues}")

        # Check for periodicity
        for period in range(1, min(10, len(residues)//2)):
            periodic = True
            for i in range(period, len(residues)):
                if residues[i] != residues[i % period]:
                    periodic = False
                    break
            if periodic:
                print(f"  PERIODIC with period {period}!")
                break

def main():
    print("Loading k values from database...")
    k = load_k_values()
    print(f"Loaded {len(k)} k values")

    # Get sequences
    adj = compute_adj(k)
    m_vals, d_vals = compute_m_d(k)

    k_list = [k[n] for n in sorted(k.keys())]
    adj_list = [adj[n] for n in sorted(adj.keys())]

    # Run tests
    test_lcg_detection(k_list)
    test_lfsr_detection(k)
    test_adj_recurrence(adj)
    test_binary_patterns(k)
    test_gcd_patterns(k)
    test_modular_patterns(k)

    # Summary
    print("\n" + "="*60)
    print("SUMMARY")
    print("="*60)
    print("Key observations to investigate further:")
    print("1. adj[n] sign pattern: ++- for n=2-16, breaks at n=17 (Fermat prime)")
    print("2. GCD patterns may reveal multiplicative structure")
    print("3. k[9], k[12], k[15] are 'prime-like' (coprime with predecessors)")
    print("4. Binary patterns may show construction preference")

if __name__ == "__main__":
    main()
