# H3 Results: PRNG (Pseudo-Random Number Generators)
**Completed**: 2025-12-19
**Runtime**: ~8 minutes
**Hypothesis**: drift[k][lane] = PRNG(seed).next() mod 256

---

## Summary

**Overall Accuracy**: 69.20% (LCG)

### Best Results:
| PRNG Type | Parameters | Accuracy |
|-----------|------------|----------|
| **LCG (MINSTD)** | seed=0 | **69.20%** |
| Python random | seed=12345 | 0.9% |
| NumPy random | seed=0 | 0.7% |
| Brute force (0-100k) | seed=15425 | 15.0% (sample) |

---

## Tests Performed

1. ✅ Python random.Random() with common seeds
2. ✅ NumPy random with common seeds
3. ✅ Standard LCG variants (MINSTD, GLIBC, BORLAND, NUMERICAL_RECIPES)
4. ✅ Brute force seed search (100,000 seeds)
5. ✅ Custom PRNG patterns (counter, Fibonacci)

---

## Key Finding: LCG = Modular Arithmetic!

**LCG got 69.2%** - almost identical to **H1's modular accuracy (69.57%)**!

This is NOT coincidence. LCG formula:
```
X_{n+1} = (a × X_n + c) mod m
```

This is the SAME as modular arithmetic tested in H1!

**Conclusion**: The drift has a linear/modular component but is NOT purely generated by a standard PRNG.

---

## Implications

The ~69% accuracy ceiling appears in both:
- H1: Modular arithmetic (69.57%)
- H3: LCG PRNG (69.20%)

This suggests:
1. **70% of drift values follow linear patterns**
2. **30% require additional logic** (non-linear component)
3. **Lanes 9-15 are always 0** (confirmed in H1)
4. **Lanes 0-8 have complex patterns**

---

## Verdict

❌ **PRNG hypothesis FAILED** (not exact enough)

✅ **CONFIRMED: Drift has ~70% linear/modular structure**

The remaining 30% likely comes from:
- Conditional logic based on k or lane
- Lookup tables for specific (k, lane) pairs
- Combination with other patterns (recursive, algorithmic)

**Recommendation**: Run H4 (recursive patterns) to capture the remaining 30%

---

## Connection to H1

Both H1 and H3 hit the **same 69% accuracy ceiling**:
- H1 tested: `drift = (mult × k + offset) mod 256`
- H3 tested: `drift = LCG(seed) mod 256`
- **Both are equivalent!** (LCG IS modular arithmetic)

This strongly suggests the drift generator uses:
```
drift[k][lane] = linear_component(k, lane) + non_linear_correction(k, lane)
```

Where:
- Linear component = 70% accuracy
- Non-linear correction = missing 30%

Next: H4 to find the non-linear component!
